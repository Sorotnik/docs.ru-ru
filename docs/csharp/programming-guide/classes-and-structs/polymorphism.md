---
title: Руководство по программированию на C#. Полиморфизм
description: Узнайте о полиморфизме, ключевом понятии в объектно-ориентированных языках программирования, таких как C#, которое описывает связь между базовым и производным классами.
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 59b5f5d2d5a8f274845607aeca370c316670bd68
ms.sourcegitcommit: 40de8df14289e1e05b40d6e5c1daabd3c286d70c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/22/2020
ms.locfileid: "86925453"
---
# <a name="polymorphism-c-programming-guide"></a>Полиморфизм (Руководство по программированию на C#)

Полиморфизм часто называется третьим столпом объектно-ориентированного программирования после инкапсуляции и наследования. Полиморфизм — слово греческого происхождения, означающее "многообразие форм" и имеющее несколько аспектов.
  
- Во время выполнения объекты производного класса могут обрабатываться как объекты базового класса в таких местах, как параметры метода и коллекции или массивы. Когда возникает полиморфизм, объявленный тип объекта перестает соответствовать своему типу во время выполнения.
- Базовые классы могут определять и реализовывать [виртуальные](../../language-reference/keywords/virtual.md) *методы*, а производные классы — [переопределять](../../language-reference/keywords/override.md) их, т. е. предоставлять свое собственное определение и реализацию. Во время выполнения, когда клиент вызывает метод, CLR выполняет поиск типа объекта во время выполнения и вызывает перезапись виртуального метода. В исходном коде можно вызвать метод в базовом классе и обеспечить выполнение версии метода, относящейся к производному классу.

Виртуальные методы позволяют работать с группами связанных объектов универсальным способом. Представим, например, приложение, позволяющее пользователю создавать различные виды фигур на поверхности для рисования. Во время компиляции вы еще не знаете, какие именно виды фигур создаст пользователь. При этом приложению необходимо отслеживать все различные типы создаваемых фигур и обновлять их в ответ на движения мыши. Для решения этой проблемы можно использовать полиморфизм, выполнив два основных действия.

1. Создать иерархию классов, в которой каждый отдельный класс фигур является производным из общего базового класса.
1. Применить виртуальный метод для вызова соответствующего метода на любой производный класс через единый вызов в метод базового класса.

Для начала создайте базовый класс с именем `Shape` и производные классы, например `Rectangle`, `Circle` и `Triangle`. Присвойте классу `Shape` виртуальный метод с именем `Draw` и переопределите его в каждом производном классе для рисования конкретной фигуры, которую этот класс представляет. Создайте объект `List<Shape>` и добавьте в него `Circle`, `Triangle`и `Rectangle`.

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

Для обновления поверхности рисования используйте цикл [foreach](../../language-reference/keywords/foreach-in.md), чтобы выполнить итерацию списка и вызвать метод `Draw` на каждом объекте `Shape` в списке. Несмотря на то, что каждый объект в списке имеет объявленный тип `Shape`, будет вызван тип времени выполнения (переопределенная версия метода в каждом производном классе).

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

В C# каждый тип является полиморфным, так как все типы, включая пользовательские, наследуют <xref:System.Object>.  

## <a name="polymorphism-overview"></a>Обзор полиморфизма

### <a name="virtual-members"></a>Виртуальные члены

Если производный класс наследуется от базового, он получает все его методы, поля, свойства и события. Конструктор производного класса может выбирать различные варианты поведения виртуальных методов:

- Производный класс может переопределять виртуальные члены в базовом классе, определяя новое поведение.
- Производный класс наследует ближайший метод базового класса без его переопределения, сохраняя существующее поведение, но позволяя дальнейшим производным классам переопределять метод.
- Производный класс может определить новую, невиртуальную реализацию тех членов, которые скрывают реализации базового класса.

Производный класс может переопределить член базового класса, только если последний будет объявлен [виртуальным](../../language-reference/keywords/virtual.md) или [абстрактным](../../language-reference/keywords/abstract.md). Производный член должен использовать ключевое слово [override](../../language-reference/keywords/override.md), указывающее, что метод предназначен для участия в виртуальном вызове. Примером является следующий код:

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

Поля не могут быть виртуальными. Виртуальными могут быть только методы, свойства, события и индексаторы. Когда производный класс переопределяет виртуальный член, он вызывается даже в том случае, если доступ к экземпляру этого класса осуществляется в качестве экземпляра базового класса. Примером является следующий код:

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#SnippetTestVirtualMethods)]

Виртуальные методы и свойства позволяют производным классам расширять базовый класс без необходимости использовать реализацию базового класса метода. Дополнительные сведения см. в разделе [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md). Еще одну возможность определения метода или набора методов, реализация которых оставлена производным классам, дает интерфейс. Дополнительные сведения см. в разделе [Интерфейсы](../interfaces/index.md).

### <a name="hide-base-class-members-with-new-members"></a>Сокрытие членов базового класса новыми членами

Если вы хотите, чтобы производный класс имел член с тем же именем, что и член в базовом классе, можно использовать ключевое слово [new](../../language-reference/keywords/new-modifier.md), чтобы скрыть член базового класса. Ключевое слово `new` вставляется перед типом возвращаемого значения замещаемого члена класса. Примером является следующий код:

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

Доступ к скрытым членам базового класса можно осуществлять из клиентского кода приведением экземпляра производного класса к экземпляру базового класса. Пример:

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a>Защита виртуальных членов от переопределения производными классами  

Виртуальные члены остаются виртуальными независимо от количества классов, объявленных между виртуальным членом и классом, который объявил его изначально. Если класс `A` объявляет виртуальный член, класс `B` является производным от класса `A`, а класс `C` — от класса `B`, то класс `C` наследует виртуальный член и может переопределить его независимо от того, объявляет ли класс `B` переопределение этого члена. Примером является следующий код:

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

Производный класс может остановить виртуальное наследование, объявив переопределение как [запечатанное](../../language-reference/keywords/sealed.md). Для остановки наследования в объявление члена класса нужно вставить ключевое слово `sealed` перед ключевым словом `override`. Примером является следующий код:

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

В предыдущем примере метод `DoWork` более не является виртуальным ни для одного класса, производного от класса `C`. Он по-прежнему является виртуальным для экземпляров класса `C`, даже если они приводятся к типу `B` или типу `A`. Запечатанные методы можно заменить производными классами с помощью ключевого слова `new`, как показано в следующем примере:

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

В этом случае, если `DoWork` вызывается для `D` с помощью переменной типа `D`, вызывается новый `DoWork`. Если переменная типа `C`, `B` или `A` используется для доступа к экземпляру `D`, вызов `DoWork` будет выполняться по правилам виртуального наследования и направлять эти вызовы в реализацию `DoWork` в классе `C`.

### <a name="access-base-class-virtual-members-from-derived-classes"></a>Доступ к виртуальным членам базового класса из производных классов

Производный класс, который заменил или переопределил метод или свойство, может получить доступ к методу или свойству на базовом классе с помощью ключевого слова `base`. Примером является следующий код:

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

Дополнительные сведения см. в разделе [base](../../language-reference/keywords/base.md).

> [!NOTE]
> Рекомендуется, чтобы виртуальные члены использовали `base` для вызова реализации базового класса этого члена в их собственной реализации. Разрешение поведения базового класса позволяет производному классу концентрироваться на реализации поведения, характерного для производного класса. Если реализация базового класса не вызывается, производный класс сопоставляет свое поведение с поведением базового класса по своему усмотрению.

## <a name="in-this-section"></a>Содержание раздела

- [Управление версиями с помощью ключевых слов Override и New](./versioning-with-the-override-and-new-keywords.md)
- [Использование ключевых слов Override и New](./knowing-when-to-use-override-and-new-keywords.md)
- [Практическое руководство. Переопределение метода ToString](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Наследование](./inheritance.md)
- [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md)
- [Методы](./methods.md)
- [События](../events/index.md)
- [Свойства](./properties.md)
- [Индексаторы](../indexers/index.md)
- [Типы](../types/index.md)
